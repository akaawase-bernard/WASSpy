#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Jun 30 21:52:21 2024

@author: bernard
"""


import numpy as np
from netCDF4 import Dataset
from tqdm import tqdm
from scipy.interpolate import griddata
import scipy
import glob 
import wasspy as wp
import matplotlib.pyplot as plt




baseline = 1.87
minx = -15 #-27
miny = -40
maxy= -10 # -19 #-19 #20
fontsize = 20
resolution = 0.2
VERSION = 2.0
fps = 12
fillvalue = 99
num_processors = 2 #65
first_frame = 1
last_frame = 8 #15#99 #21578
interval = 1






# Set the paths here
pth = '../tests/'
file = 'surfaces_201309_gridded_test.nc'
task = 'gridding/'
checks = 0

#pth = '/scratch/lab/data/bernard/wass/'
#pth =  '/Users/bernard/airsea/data/bernard/wass/'
# project = 'BS_2013'
# exp = '/2013-09-30_10-20-01_12Hz/'
# #workdir = pth + project  + exp + 'wass_output/'
# workdir = pth + project  + exp + 'output/'
# #planedir = pth + project  + exp + 'data/wass_mean_plane/'
# filename = pth + project + exp + task + file
# planepth = workdir +'/median_plane.txt'




#for the test
workdir = pth + 'output/'
filename = pth + task + file
planepth = workdir +'/median_plane.txt'


#get the shape of the gridded data to create .nc coords
x_arr = np.arange(minx, abs(minx),resolution)
y_arr = np.arange(miny, maxy,resolution)
XX, YY = np.meshgrid(x_arr, y_arr)
Ny, Nx = np.shape(XX)


wass_frames = list()
for element in range(first_frame,last_frame, interval):
    wass_framepth = workdir + str(element).zfill(6) + '_wd' #create 6 zeros and append frame number
    wass_frames.append(wass_framepth)



def process_frame(num):
 
    #WASS xyz loading
    iw, jw, x, y, elevations = wp.load_camXYZ(workdir, 
                                            n=num, baseline = baseline, 
                                            checks =0) #---- import WASS data
    

    #interpolate
    x_arr = np.arange(minx, abs(minx),resolution)
    y_arr = np.arange(miny, maxy,resolution)
    XX, YY = np.meshgrid(x_arr, y_arr)
    
    
    #run the ffgridding function
    xx, yy, zz = wp.ffgrid(x, y, elevations, x_arr, y_arr, resolution, resolution)
    x_gridded = np.squeeze(xx.flatten())
    y_gridded = np.squeeze(yy.flatten())
    z_gridded = np.squeeze(zz.flatten())
    ind_nonans = np.where(~np.isnan(z_gridded)) #indices that are free from nans


    #run our interp fc
    interpolator_z = wp.interpolate(x_gridded[ind_nonans], y_gridded[ind_nonans], z_gridded[ind_nonans])
    ind_nan = np.where(np.isnan(z_gridded))
    Zi = z_gridded
    Zi[ind_nan] = interpolator_z(x_gridded[ind_nan], y_gridded[ind_nan])
    Zi = Zi.reshape(np.shape(xx))

    if checks:
        fig = plt.figure(figsize=(8,5) )
        plt.pcolor( xx,yy,Zi, cmap='RdBu', vmin =-1.2, vmax =1.2)
        plt.gca().invert_yaxis()
        plt.colorbar()
        plt.title('Frame ' + str(num).zfill(6))
        #figfile = path.join(outdir,"interpolated_data.png" )
        #fig.savefig(figfile,bbox_inches='tight')
        
    

    #Zi = griddata((x,y),elevations,(XX, YY))  #backup ... slowerr
    Zdata = scipy.ndimage.median_filter(Zi, size=2)
    return Zdata.T


if __name__ == '__main__':
    
    with Dataset(filename, 'w') as ds:  # Create the NetCDF file
        ds.createDimension('frame', len(wass_frames))  # Create the dimensions
        ds.createDimension('X', Nx)
        ds.createDimension('Y', Ny)
        ds.createDimension('count', len(wass_frames))

        Z = ds.createVariable("Z", "f4", ("count", "X", "Y"))  # Create the variables
        Z.units = "meter"
        Z.long_name = "Z data in time over the XY grid"
        Z.field = "Z, scalar, series"

        xgrid = ds.createVariable("X_grid", "f8", ("X", "Y"))
        xgrid.units = "meter"
        xgrid.long_name = "X axis grid"
        xgrid.field = "X_grid, scalar, series"

        ygrid = ds.createVariable("Y_grid", "f8", ("X", "Y"))
        ygrid.units = "meter"
        ygrid.long_name = "Y axis grid"
        ygrid.field = "Y_grid, scalar, series"

        count = ds.createVariable('count', 'i', ('count',))
        scale = ds.createVariable("scale", "f8")
        scale.long_name = "scale"
        scale.units = "meter"

        # Set additional attributes
        ds.setncattr("info", "Generated by UCONN AirSea Lab v.%s" % VERSION)
        ds.setncattr("baseline", baseline)
        ds.setncattr("fps", fps)

        # Create a pool of workers
        from concurrent.futures import ProcessPoolExecutor, as_completed
        with ProcessPoolExecutor(max_workers=num_processors) as executor:
            # Submit the frames to worker processes
            futures = {executor.submit(process_frame, i): i for i in range(len(wass_frames))}
            
            # Collect the results as they complete
            results = []
            for future in tqdm(as_completed(futures), total=len(futures), desc="Processed frames"):
                result = future.result()
                results.append(result)
        
        for num, (Zdata) in enumerate(results):
            Z[num, :, :] = Zdata
        
        # Set the values for count and scale variables
        count[:] = range(len(wass_frames))
        scale[:] = baseline
        print("NetCDF file created and data written.")
